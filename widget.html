<!DOCTYPE html>
<html>

<head>
    <meta http-equiv="content-type" content="text/html; charset=UTF-8">

    <title><!--(auto-fill by runme.js--></title>

    <!-- ChiliPeppr is based on bootstrap CSS. -->
    <link rel="stylesheet" type="text/css" href="//netdna.bootstrapcdn.com/bootstrap/3.1.1/css/bootstrap.min.css">

    <!-- Customized version of require.js for ChiliPeppr. Please see require.js docs for how
    ChiliPeppr's dependency system works as it's based on require.js. -->
    <script type='text/javascript' src="//i2dcui.appspot.com/js/require.js"></script>

    <!-- widget.css DON'T REMOVE -->
    <style type='text/css'>
        /* widget.css will get inlined here by runme.js. don't remove this comment or inlining will fail. */
    </style>
    <link rel="stylesheet" type="text/css" href="widget.css">
    <!-- DON'T REMOVE end widget.css -->

    <!-- widget.js DON'T REMOVE -->
    <script type='text/javascript'>
        //<![CDATA[
        /* widget.js will get inlined here by runme.js. don't remove this comment or inlining will fail. */
        //]]>
    </script>
    <script type='text/javascript' src="widget.js"></script>
    <!-- DON'T REMOVE end widget.js -->

</head>

<body>
    <div id="com-chilipeppr-widget-esp32-docs" class="panel panel-default">
        <div class="panel-heading ">

            <div class="btn-toolbar pull-right" role="toolbar">
                <div class="btn-group hidden">
                    <button type="button" class="btn btn-xs btn-default btn-sayhello" data-delay="1000" data-animation="true" 
                    data-placement="auto" data-container="body" data-trigger="hover" 
                    data-title="Say Hello" data-content="Generate a hello message">Say Hello
                    </button>
                </div>
                <div class="btn-group">
                    <button type="button" class="btn btn-xs btn-default hidebody"><span class="glyphicon glyphicon-chevron-up"></span>
                    </button>
                </div>
                <div class="btn-group">
                    <div class="dropdown">
                        <button type="button" class="btn btn-xs btn-default dropdown-toggle" data-toggle="dropdown"><span class="caret"></span>
                        </button>
                        <ul class="dropdown-menu dropdown-menu-right" role="menu"></ul>
                    </div>
                </div>
            </div> <span class="panel-title" data-toggle="popover">Firmware / Docs</span> <span style="font-size:9px;" class="hidden fb-build">v1</span>

        </div>
        <div class="panel-body">
            <!-- Nav tabs -->
            <ul class="nav nav-tabs" role="tablist">
                <!--<li class="active"><a href="#com-chilipeppr-widget-template-tab1" role="tab" data-toggle="tab">Tab 1</a></li>-->
                <li class="active"><a href="#com-chilipeppr-widget-tab-nodemcu-firmware" role="tab" data-toggle="tab">Firmware</a></li>
                <li class="xhidden"><a href="#com-chilipeppr-widget-tab-nodemcu-docs" role="tab" data-toggle="tab">Docs</a></li>
                <li class="xhidden"><a href="#com-chilipeppr-widget-tab-nodemcu-samples" role="tab" data-toggle="tab">Sample Code</a></li>
                <!--<li><a href="#com-chilipeppr-widget-tab-file" role="tab" data-toggle="tab">File</a></li>-->
                <!--<li><a href="#com-chilipeppr-widget-tab-wifi" role="tab" data-toggle="tab">Wifi</a></li>-->
                <!--<li><a href="#com-chilipeppr-widget-tab-timer" role="tab" data-toggle="tab">Timer</a></li>-->
                <!--<li><a href="#com-chilipeppr-widget-tab-gpio" role="tab" data-toggle="tab">GPIO</a></li>-->

            </ul>
            <!-- Tab panes -->

            <!-- Tab 1 -->
            <div class="tab-content">
                <div class="tab-pane active" id="com-chilipeppr-widget-tab-nodemcu-firmware">
                    
                    <div class="billboard-img" style="height:100px; background-image: url('https://raw.githubusercontent.com/chilipeppr/widget-esp32-docs/master/Wemos-Lolin32-Large.jpg');">
                    </div>
                    <div style="padding:10px;">
                        <p>Install Latest Firmware on your ESP32 for Lua (NodeMCU)</p>
                        <ol>
                            <li>Dowload the esp32tool.zip from Github release page.
                            ChiliPeppr has a pre-compiled firmware for ESP32 for Lua in this file
                            on the Github repository for this workspace in a file called esp32tool.zip.
                            <a target="_blank" href="https://github.com/chilipeppr/workspace-esp32-lua/releases">https://github.com/chilipeppr/workspace-esp32-lua/releases</a>.
                            </li>
                            <li>You also need to have <a href="https://www.python.org/downloads/">Python 2.7 installed</a>.</li>
                            <li>Once you have Python installed and have downloaded esp32tool.zip, extract esp32tool.zip, then
                            open a terminal window or command line to the directory you extracted esp32tool.zip into.</li>
                            <li>Install esptool.py from pip from your command line by running the command below. 
                            <pre>pip install esptool</pre>
                            If you need extra help on installing and running esptool.py then visit <a target="_blank" href="https://github.com/espressif/esptool">https://github.com/espressif/esptool</a>
                            
                            </li>
                            <li>
                            Then run the command below, but make sure to set your serial port to the correct port your ESP32.
                            <pre>esptool.py --port COM7 write_flash 0x1000 bootloader.bin 0x10000 NodeMCU-esp32-adc-bit-bluetooth-can-dht-i2c-ledc-u8g2-ws2812.bin 0x8000 partitions_singleapp.bin</pre>
                            
                            </li>
                            <li>You should now have a fully programmed ESP32 ready to use in this workspace. Hit refresh in 
                            the Serial Port JSON Server widget and open the serial port to your device by clicking on it.</li>
                            <li>For further help, <a target="_blank" href="">watch the firmware install video tutorial on Youtube</a>.</li>
                        </ol>

                        
                    </div>
                

                </div>

                <!-- Tab Documentation -->
                <div class="tab-pane" id="com-chilipeppr-widget-tab-nodemcu-docs">
                    
                    <p style="padding-top:10px">Documentation</p>
                    <ol>
                        <li><a href="https://nodemcu.readthedocs.io/en/dev-esp32/" target="_blank">https://nodemcu.readthedocs.io/en/dev-esp32/</a></li>
                    </ol>
                </div>

                <!-- Tab Documentation -->
                <div class="tab-pane" id="com-chilipeppr-widget-tab-nodemcu-samples">
                    
                    <!--<p style="padding-top:10px">Sample Code</p>-->
                
                    <!-- begin code sample -->
                    <div class="code-sample-with-send">
                        <div class="bs-example" data-example-id="inline-code"> 
                            <div class="bs-example-title">Blink LED</div>
                            Start blinking an LED. This code tries port 2, 13, and 16 which are common on 
                            ESP32 devices like the Wemos, TTGO, and Doit boards.
                            <div class="btn-group upper-right-btn-group" role="group">
                                <!--<button type="button" class="btn btn-sm btn-default xbtn-clipboard">Run</button>-->
                                <button type="button" class="btn btn-sm btn-default xbtn-clipboard btn-sendtoeditor"><span class="glyphicon glyphicon-edit"></span> Editor</button>
                            </div>
    
                        </div>
                        <div class="code-sample-wrapper code-sample-collapsed upper-right-buttons">
                            <figure class="highlight">
                                <pre><code class="language-javascript" 
                                data-lang="javascript" data-filename="blink_led"
                                >-- ChiliPeppr - Blink built-in LEDs on ESP32 devices
m = {}

-- Config
-- Try pings 2 on DOIT, 13 on TTGO, 16 on Wemos
m.pins = {ESP32_DOIT = 2, ESP32_TTGO = 13, ESP32_Wemos = 16} 
m.value = 0
m.duration = 500
m.ctr = 0

function m.toggleLED ()
  if m.value == 0 then
    m.value = 1
  else
    m.value = 0
  end
  
  -- print("Toggling")
  for key, value in pairs(m.pins) do
    local pin = value
    gpio.write(pin, m.value)
    -- print("Toggled " .. pin)
  end
  
  -- m.ctr = m.ctr + 1
  -- if m.ctr > 10 then
  --   m.mytimer:unregister()
  -- end
end

-- Initialise the pins
print("Initializing pins")
for key, value in pairs(m.pins) do
  print("Initting LED pin for ESP32 device: ", key, "pin:", value)
  gpio.config( { gpio={value}, dir=gpio.OUT } )
end

-- tmr.alarm(0, duration, 1, toggleLED)
m.mytimer = tmr.create()
m.mytimer:alarm(m.duration, tmr.ALARM_AUTO, m.toggleLED)</code></pre>
                            </figure>
                            <div class="btn-group btn-group-codeexpander">
                                <button type="button" class="btn btn-xs btn-default btn-collapsecode"><span class="glyphicon glyphicon-chevron-down"></span>
                                </button>
                            </div>

                        </div>
                    </div>
                    <!-- end code sample -->
                    
                    <!-- begin code sample -->
                    <div class="code-sample-with-send">
                        <div class="bs-example" data-example-id="inline-code"> 
                            <div class="bs-example-title">WS281xx LEDs</div>
                            Control your WS2812, WS2813, or other strand LEDs from your ESP32.
                            <div class="btn-group upper-right-btn-group" role="group">
                                <!--<button type="button" class="btn btn-sm btn-default xbtn-clipboard">Run</button>-->
                                <button type="button" class="btn btn-sm btn-default xbtn-clipboard btn-sendtoeditor"><span class="glyphicon glyphicon-edit"></span> Editor</button>
                            </div>
    
                        </div>
                        <div class="code-sample-wrapper code-sample-collapsed upper-right-buttons">
                            <figure class="highlight">
                                <pre><code class="language-javascript" 
                                data-lang="javascript" data-filename="ws281x_leds"
                                >-- ChiliPeppr - WS2812/WS2813 LED library

-- local ZLed = {}
ZLed = {}

ZLed.pin = 4
ZLed.strandLength = 4
ZLed.buffer = ws2812.newBuffer(ZLed.strandLength, 3); 
ZLed.t = tmr.create()

ZLed.isBusy = false

function ZLed.chase(r, g, b)
  -- local isRun, mode = ZLed.t:state()
  -- if isRun == true then return end
  if ZLed.isBusy then return end

  ZLed.isBusy = true
  
  if r == nil then r = 0 end
  if g == nil then g = 0 end
  if b == nil then b = 255 end
  local i = 0
  ZLed.buffer:fill(0, 0, 0); 
  ZLed.t:alarm(100, tmr.ALARM_AUTO, function()
    i = i + 1
    ZLed.buffer:fade(5)
    ZLed.buffer:set(i % ZLed.buffer:size() + 1, g, r, b)
    ws2812.write({pin = ZLed.pin, data = ZLed.buffer})
  end)
end

function ZLed.pulse(r, g, b)
  
  print("Starting pulse animation")

  -- normal run  
  -- local isRun, mode = ZLed.t:state()
  -- if isRun == true then return end
  if ZLed.isBusy then return end

  ZLed.isBusy = true

  if r == nil then r = 0 end
  if g == nil then g = 0 end
  if b == nil then b = 255 end
  local pulseCtr = 0
  local direction = 2
  -- buffer:fill(g, r, b);
  -- buffer:fade(5)
  ws2812.write({pin = ZLed.pin, data = ZLed.buffer})
  print("About to start AUTO alarm on pulse")
  ZLed.t:alarm(10, tmr.ALARM_AUTO, function()
    pulseCtr = pulseCtr + direction
    
    local r2 = 0
    local g2 = 0
    local b2 = 0
    
    if pulseCtr <= 3 then direction = 2 end
    if pulseCtr >= 100 then direction = -2 end
    if pulseCtr <= r then r2 = pulseCtr end
    if pulseCtr <= g then g2 = pulseCtr end
    if pulseCtr <= b then b2 = pulseCtr end
    
    ZLed.buffer:fill(g2, r2, b2);
    
    ws2812.write({pin = ZLed.pin, data = ZLed.buffer})
    
  end)
  -- buffer:fade(2, ws2812.FADE_IN)
end

function ZLed.pause()
  if ZLed.isBusy then
    ZLed.t:stop()
    print("Paused LED anim")
    ZLed.isBusy = false
  end
end

function ZLed.resume()
  if ZLed.isBusy == false then
    local running, mode = ZLed.t:state()
    if running ~= nil then
      -- means is registered
      ZLed.isBusy = true
      ZLed.t:start()
      print("Resumed LED anim")
    end
  end
end

function ZLed.fill(r, g, b)
  if r == nil then r = 0 end
  if g == nil then g = 0 end
  if b == nil then b = 0 end
  ZLed.buffer:fill(g, r, b);
  ws2812.write({pin = ZLed.pin, data = ZLed.buffer})
end
    
function ZLed.stop()
  print("ZLed stop. Stopping other LED ops.")
  
  -- if ZLed.isBusy == false then
  --   print("Being asked to stop LED anim, but not running")
  --   return
  -- end
  
  local isRun, mode = ZLed.t:state()
  if isRun == true then ZLed.t:stop() end
  if isRun ~= nil then 
    ZLed.t:unregister()
  end
  ZLed.isBusy = false
  
  -- just do set color without fade to resolve possible bug
  ZLed.fill(7, 3, 0) -- just enough to show we're on
  if true then return end
  
  local i = 0
  local tmrFadeBack = tmr.create()
  tmrFadeBack:alarm(100, tmr.ALARM_AUTO, function()
    i = i + 1
    ZLed.buffer:fade(2)
    ws2812.write({pin = ZLed.pin, data = ZLed.buffer})
    if i > 30 then 
      tmrFadeBack:stop()
      tmrFadeBack:unregister()
      -- ZLed.fill(3, 2, 0) -- just enough to show we're on
      ZLed.fill(7, 3, 0) -- just enough to show we're on
    end
  end)
  -- buffer:fill(0, 0, 0);
  -- ws2812.write({pin = ZLed.pin, data = buffer})
end

function ZLed.indicateDataSent()
   -- indicate to lights that we are starting our tcp request
  -- local isRun, mode = ZLed.t:state()
  -- if isRun then return end
  if ZLed.isBusy then return end
  print("indicateDataSent")
  led.buffer:set(1, 10, 0, 0)
  ws2812.write({pin = ZLed.pin, data = led.buffer})
    
end

function ZLed.indicateDataRecvd()
  -- indicate to lights that we are done with our tcp request
  -- local isRun, mode = ZLed.t:state()
  -- if isRun then return end
  if ZLed.isBusy then return end
  print("indicateDataRecvd")
  -- led.buffer:set(1, 0, 0, 0)
  led.buffer:set(1, 3, 7, 0) -- base color of light orange
  ws2812.write({pin = ZLed.pin, data = led.buffer})
  
end

function ZLed.indicateDataDisconnectErr()
 -- indicate to lights that we are done with our tcp request
  -- local isRun, mode = ZLed.t:state()
  -- if isRun then return end
  if ZLed.isBusy then return end
  led.buffer:set(1, 0, 10, 0)
  ws2812.write({pin = ZLed.pin, data = led.buffer})
  
end

-- ZLed.pulse(0, 0, 255)
ZLed.chase(255, 0, 0)

-- return ZLed</code></pre>
                            </figure>
                            <div class="btn-group btn-group-codeexpander">
                                <button type="button" class="btn btn-xs btn-default btn-collapsecode"><span class="glyphicon glyphicon-chevron-down"></span>
                                </button>
                            </div>

                        </div>
                    </div>
                    <!-- end code sample -->

                    <!-- begin code sample -->
                    <div class="code-sample-with-send">
                        <div class="bs-example" data-example-id="inline-code"> 
                            <div class="bs-example-title">JSON</div>
                            Encode and decode JSON with a pure LUA library.
                            <div class="btn-group upper-right-btn-group" role="group">
                                <!--<button type="button" class="btn btn-sm btn-default xbtn-clipboard">Run</button>-->
                                <button type="button" class="btn btn-sm btn-default xbtn-clipboard btn-sendtoeditor"><span class="glyphicon glyphicon-edit"></span> Editor</button>
                            </div>
    
                        </div>
                        <div class="code-sample-wrapper code-sample-collapsed upper-right-buttons">
                            <figure class="highlight">
                                <pre><code class="language-javascript" 
                                data-lang="javascript" data-filename="json_test"
                                >-- ChiliPeppr - Test your JSON library
json = require('json')

-- Decode: Test a success
data = '{"Cmd":"GetQ"}'
succ, results = pcall(json.decode, data)

-- see if we could parse. should give an error
if succ then
  print("success. results:", results)
  for k,v in pairs(results) do print(k,v) end 
else 
  print("err. results:", results)
end 

-- Decode: Test a failure
data = '{"Cmd":"GetQ"'
succ, results = pcall(json.decode, data)

-- see if we could parse. should give an error
if succ then
  print("success. results:", results)
else 
  print("err. results:", results)
end 

-- Encode: Test a success
data = {}
data.Item1 = "blah"
data.Item2 = "neat"
data.Item3 = {}
data.Item3.Inner1 = 10
data.Item3.Inner2 = 20
print(json.encode(data))
</code></pre>
                                <pre><code class="language-javascript" 
                                data-lang="javascript" data-filename="json"
                                >-- ChiliPeppr tweaked version of rxi's awesome JSON library in pure Lua code to make it work
-- seamlessly on ESP32 since there is no firmware level JSON library like cjson or sjson for ESP32 yet.
-- Very minimal changes were made to get this to work.
--
-- To use:
-- json = require('json')

--
-- json.lua
--
-- Copyright (c) 2015 rxi
--
-- This library is free software; you can redistribute it and/or modify it
-- under the terms of the MIT license. See LICENSE for details.
--

local json = { _version = "0.1.0" }

-------------------------------------------------------------------------------
-- Encode
-------------------------------------------------------------------------------

local encode

local escape_char_map = {
  [ "\\" ] = "\\\\",
  [ "\"" ] = "\\\"",
  [ "\b" ] = "\\b",
  [ "\f" ] = "\\f",
  [ "\n" ] = "\\n",
  [ "\r" ] = "\\r",
  [ "\t" ] = "\\t",
}

local escape_char_map_inv = { [ "\\/" ] = "/" }
for k, v in pairs(escape_char_map) do
  escape_char_map_inv[v] = k
end


local function escape_char(c)
  return escape_char_map[c] or string.format("\\u%04x", c:byte())
end


local function encode_nil(val)
  return "null"
end 


local function encode_table(val, stack)
  local res = {}
  stack = stack or {}

  -- Circular reference?
  if stack[val] then error("circular reference") end

  stack[val] = true

  if val[1] ~= nil or next(val) == nil then
    -- Treat as array -- check keys are valid and it is not sparse
    local n = 0
    for k in pairs(val) do
      if type(k) ~= "number" then
        error("invalid table: mixed or invalid key types")
      end
      n = n + 1
    end
    if n ~= #val then
      error("invalid table: sparse array")
    end
    -- Encode
    for i, v in ipairs(val) do
      table.insert(res, encode(v, stack))
    end
    stack[val] = nil
    return "[" .. table.concat(res, ",") .. "]"

  else
    -- Treat as an object
    for k, v in pairs(val) do
      if type(k) ~= "string" then
        error("invalid table: mixed or invalid key types")
      end
      table.insert(res, encode(k, stack) .. ":" .. encode(v, stack))
    end
    stack[val] = nil
    return "{" .. table.concat(res, ",") .. "}"
  end
end


local function encode_string(val)
  return '"' .. val:gsub('[%z\1-\31\\"]', escape_char) .. '"'
end


local function encode_number(val)
  -- Check for NaN, -inf and inf
  if val ~= val or val <= -math.huge or val >= math.huge then
    error("unexpected number value '" .. tostring(val) .. "'")
  end
  return string.format("%.14g", val)
end


local type_func_map = {
  [ "nil"     ] = encode_nil,
  [ "table"   ] = encode_table,
  [ "string"  ] = encode_string,
  [ "number"  ] = encode_number,
  [ "boolean" ] = tostring,
}


encode = function(val, stack)
  local t = type(val)
  local f = type_func_map[t]
  if f ~= nil then
    return f(val, stack)
  end
  error("unexpected type '" .. t .. "'")
end


function json.encode(val)
  return ( encode(val) )
end


-------------------------------------------------------------------------------
-- Decode
-------------------------------------------------------------------------------

local parse

local function create_set(...) 
  local res = {}
  for i = 1, select("#", ...) do
    res[ select(i, ...) ] = true
  end
  return res
end

local space_chars   = create_set(" ", "\t", "\r", "\n")
local delim_chars   = create_set(" ", "\t", "\r", "\n", "]", "}", ",")
local escape_chars  = create_set("\\", "/", '"', "b", "f", "n", "r", "t", "u")
local literals      = create_set("true", "false", "null")

local literal_map = {
  [ "true"  ] = true,
  [ "false" ] = false,
  [ "null"  ] = nil,
}


local function next_char(str, idx, set, negate)
  for i = idx, #str do
    if set[str:sub(i, i)] ~= negate then
      return i
    end
  end
  return #str + 1
end


local function decode_error(str, idx, msg)
  local line_count = 1
  local col_count = 1
  for i = 1, idx - 1 do
    col_count = col_count + 1
    if str:sub(i, i) == "\n" then
      line_count = line_count + 1
      col_count = 1
    end
  end
  error( string.format("%s at line %d col %d", msg, line_count, col_count) )
end


local function codepoint_to_utf8(n)
  -- http://scripts.sil.org/cms/scripts/page.php?site_id=nrsi&id=iws-appendixa
  local f = math.floor
  if n <= 0x7f then
    return string.char(n)
  elseif n <= 0x7ff then
    return string.char(f(n / 64) + 192, n % 64 + 128)
  elseif n <= 0xffff then
    return string.char(f(n / 4096) + 224, f(n % 4096 / 64) + 128, n % 64 + 128)
  elseif n <= 0x10ffff then
    return string.char(f(n / 262144) + 240, f(n % 262144 / 4096) + 128,
                       f(n % 4096 / 64) + 128, n % 64 + 128)
  end
  error( string.format("invalid unicode codepoint '%x'", n) )
end


local function parse_unicode_escape(s)
  local n1 = tonumber( s:sub(3, 6),  16 )
  local n2 = tonumber( s:sub(9, 12), 16 )
  -- Surrogate pair?
  if n2 then
    return codepoint_to_utf8((n1 - 0xd800) * 0x400 + (n2 - 0xdc00) + 0x10000)
  else
    return codepoint_to_utf8(n1)
  end
end


local function parse_string(str, i)
  local has_unicode_escape = false
  local has_surrogate_escape = false
  local has_escape = false
  local last
  for j = i + 1, #str do
    local x = str:byte(j)

    if x < 32 then
      decode_error(str, j, "control character in string")
    end

    if last == 92 then -- "\\" (escape char)
      if x == 117 then -- "u" (unicode escape sequence)
        local hex = str:sub(j + 1, j + 5)
        if not hex:find("%x%x%x%x") then
          decode_error(str, j, "invalid unicode escape in string")
        end
        if hex:find("^[dD][89aAbB]") then
          has_surrogate_escape = true
        else
          has_unicode_escape = true
        end
      else
        local c = string.char(x)
        if not escape_chars[c] then
          decode_error(str, j, "invalid escape char '" .. c .. "' in string")
        end
        has_escape = true
      end
      last = nil

    elseif x == 34 then -- '"' (end of string)
      local s = str:sub(i + 1, j - 1)
      if has_surrogate_escape then 
        s = s:gsub("\\u[dD][89aAbB]..\\u....", parse_unicode_escape)
      end
      if has_unicode_escape then 
        s = s:gsub("\\u....", parse_unicode_escape)
      end
      if has_escape then
        s = s:gsub("\\.", escape_char_map_inv)
      end
      return s, j + 1
    
    else
      last = x
    end
  end
  decode_error(str, i, "expected closing quote for string")
end


local function parse_number(str, i)
  local x = next_char(str, i, delim_chars)
  local s = str:sub(i, x - 1)
  local n = tonumber(s)
  if not n then
    decode_error(str, i, "invalid number '" .. s .. "'")
  end
  return n, x
end


local function parse_literal(str, i)
  local x = next_char(str, i, delim_chars)
  local word = str:sub(i, x - 1)
  if not literals[word] then
    decode_error(str, i, "invalid literal '" .. word .. "'")
  end
  return literal_map[word], x
end


local function parse_array(str, i)
  local res = {}
  local n = 1
  i = i + 1
  while 1 do
    local x
    i = next_char(str, i, space_chars, true)
    -- Empty / end of array?
    if str:sub(i, i) == "]" then 
      i = i + 1
      break
    end
    -- Read token
    x, i = parse(str, i)
    res[n] = x
    n = n + 1
    -- Next token 
    i = next_char(str, i, space_chars, true)
    local chr = str:sub(i, i)
    i = i + 1
    if chr == "]" then break end
    if chr ~= "," then decode_error(str, i, "expected ']' or ','") end
  end
  return res, i
end


local function parse_object(str, i)
  local res = {}
  i = i + 1
  while 1 do
    local key, val
    i = next_char(str, i, space_chars, true)
    -- Empty / end of object?
    if str:sub(i, i) == "}" then 
      i = i + 1
      break
    end
    -- Read key
    if str:sub(i, i) ~= '"' then
      decode_error(str, i, "expected string for key")
    end
    key, i = parse(str, i)
    -- Read ':' delimiter
    i = next_char(str, i, space_chars, true)
    if str:sub(i, i) ~= ":" then
      decode_error(str, i, "expected ':' after key")
    end
    i = next_char(str, i + 1, space_chars, true)
    -- Read value
    val, i = parse(str, i)
    -- Set
    res[key] = val
    -- Next token
    i = next_char(str, i, space_chars, true)
    local chr = str:sub(i, i)
    i = i + 1
    if chr == "}" then break end
    if chr ~= "," then decode_error(str, i, "expected '}' or ','") end
  end
  return res, i
end


local char_func_map = {
  [ '"' ] = parse_string,
  [ "0" ] = parse_number,
  [ "1" ] = parse_number,
  [ "2" ] = parse_number,
  [ "3" ] = parse_number,
  [ "4" ] = parse_number,
  [ "5" ] = parse_number,
  [ "6" ] = parse_number,
  [ "7" ] = parse_number,
  [ "8" ] = parse_number,
  [ "9" ] = parse_number,
  [ "-" ] = parse_number,
  [ "t" ] = parse_literal,
  [ "f" ] = parse_literal,
  [ "n" ] = parse_literal,
  [ "[" ] = parse_array,
  [ "{" ] = parse_object
}

parse = function(str, idx)
  local chr = str:sub(idx, idx)
  local f = char_func_map[chr]
  if f then
    return f(str, idx)
  end
  decode_error(str, idx, "unexpected character '" .. chr .. "'")
end

function json.decode(str)
  if type(str) ~= "string" then
    error("expected argument of type string, got " .. type(str))
  end
  return ( parse(str, next_char(str, 1, space_chars, true)) )
end

return json
</code></pre>
                            </figure>
                            <div class="btn-group btn-group-codeexpander">
                                <button type="button" class="btn btn-xs btn-default btn-collapsecode"><span class="glyphicon glyphicon-chevron-down"></span>
                                </button>
                            </div>

                        </div>
                    </div>
                    <!-- end code sample -->

                    <!-- begin code sample -->
                    <div class="code-sample-with-send">
                        <div class="bs-example" data-example-id="inline-code"> 
                            <div class="bs-example-title">Web Server</div>
                            Run a web server on your ESP32 to control some GPIO.
                            <div class="btn-group upper-right-btn-group" role="group">
                                <!--<button type="button" class="btn btn-sm btn-default xbtn-clipboard">Run</button>-->
                                <button type="button" class="btn btn-sm btn-default xbtn-clipboard btn-sendtoeditor"><span class="glyphicon glyphicon-edit"></span> Editor</button>
                            </div>
    
                        </div>
                        <div class="code-sample-wrapper code-sample-collapsed upper-right-buttons">
                            <figure class="highlight">
                                <pre><code class="language-javascript" 
                                data-lang="javascript" data-filename="esp32_test_webserver"
                                >-- ChiliPeppr - Test your web server

ws = require("esp32_webserver")
ws.start()

function fuelOn()
  print("turning on fuel")
  -- toggle a GPIO port
end

function fuelOff()
  print("turning off fuel")
  -- toggle a GPIO port
end

ws.registerCallbackOn(fuelOn)
ws.registerCallbackOff(fuelOff)

</code></pre>
                                <pre><code class="language-javascript" 
                                data-lang="javascript" data-filename="esp32_webserver"
                                >-- ChiliPeppr - Create webserver and host a web page

local w = {}

w.wifiSsid = "NETGEAR-main"
w.wifiPwd = "****"

w.callbackOn = nil
w.callbackOff = nil

function w.registerCallbackOn(f)
  w.callbackOn = f
end

function w.registerCallbackOff(f)
  w.callbackOff = f
end

function w.start()
  --register callback
  wifi.sta.on("got_ip", function(ev, info)
    print("NodeMCU IP config:", info.ip, "netmask", info.netmask, "gw", info.gw)
  
    print('You now have a webserver running at: http://' .. info.ip)
    print("Go visit it and see you get a nice callback to do stuff with like control GPIO ports from the web.")
  end)
  
  --unregister callback
  -- wifi.sta.on("got_ip", nil)
  
  -- set as station
  wifi.mode(1)
  -- start wifi
  wifi.start()
  
  --connect to Access Point (DO save config to flash)
  station_cfg={}
  station_cfg.ssid=w.wifiSsid
  station_cfg.pwd=w.wifiPwd
  wifi.sta.config(station_cfg, true)
  print("Saved wifi name/password")
  
  srv = net.createServer(net.TCP)

  srv:listen(80, function(conn)
    conn:on("receive", w.receiver)
  end)

end

function w.receiver(sck, data)

  print("DATA: " .. data)
  
  -- local response = {}

  -- if you're sending back HTML over HTTP you'll want something like this instead
  local response = {"HTTP/1.0 200 OK\r\nServer: ChiliPeppr ESP32\r\n"}
  
  -- SEE IF DATA IS WANTING TO TURN ON ANYTHING
  if (data:find("^GET /on" )) then
    print("being asked to turn on fuel")
    response[#response + 1] = "Access-Control-Allow-Origin: *\r\nContent-Type: application/json\r\n\r\n"
    -- response[#response + 1] = "<b>Turning on fuel</b><br><br>"
    response[#response + 1] = '{"isFuelOn": true}'
    w.callbackOn()
  elseif (data:find("^GET /off" )) then
    print("being asked to turn off fuel")
    response[#response + 1] = "Access-Control-Allow-Origin: *\r\nContent-Type: application/json\r\n\r\n"
    -- response[#response + 1] = "<b>Turning off fuel</b><br><br>"
    response[#response + 1] = '{"isFuelOn": false}'
    w.callbackOff()
  else
    response[#response + 1] = "Content-Type: text/html\r\n\r\n"
    response[#response + 1] = '<a href="/on">Turn on fuel</a><br>'
    response[#response + 1] = '<a href="/off">Turn off fuel</a><br>'
    response[#response + 1] = "<br>even more data "
    response[#response + 1] = "e.g. you coulud content read from a file"
  
  end

  
  -- sends and removes the first element from the 'response' table
  local function send(localSocket)
    if #response > 0 then
      localSocket:send(table.remove(response, 1))
    else
      localSocket:close()
      response = nil
    end
  end

  -- triggers the send() function again once the first chunk of data was sent
  sck:on("sent", send)

  send(sck)
end

return w
</code></pre>
                            </figure>
                            <div class="btn-group btn-group-codeexpander">
                                <button type="button" class="btn btn-xs btn-default btn-collapsecode"><span class="glyphicon glyphicon-chevron-down"></span>
                                </button>
                            </div>

                        </div>
                    </div>
                    <!-- end code sample -->

                </div>

                <!-- Tab GPIO -->
                <div class="tab-pane" id="com-chilipeppr-widget-tab-gpio">
                </div>


            </div>

        </div>
    </div>
</body>

</html>
